<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>(2017 NOSSDAV) Not so QUIC A Performance Study of DASH over QUIC | Jonathan&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="Summary QUICä¸åŠTCPåœ¨DASHçš„è¡¨ç¾ï¼Œç”±æ–¼å¤§å¤šæ•¸ABR algorighméƒ½ç¶“éå„ªåŒ–èˆ‡TCPé…åˆä½¿ç”¨ï¼Œå› æ­¤æ²’æœ‰å……åˆ†åˆ©ç”¨QUICæä¾›çš„åŠŸèƒ½ã€‚ Problem statement What is the impact of QUIC on QoE? How should adaptive bitrate streaming be built to leverage the benefits provided by QUIC? Research objectives A Performance Study and future work Methods we studied QoE performance of different DASH quality adaptation algorithms that are either solely based on the playout buffer filling, or on the video segment download rate, or on both. DASH quality adaptation algorithms that are mainly categorized as">
<meta name="author" content="
Author:&nbsp;Jonathan">
<link rel="canonical" href="https://jonathan-tw.github.io/posts/2017-nossdav-not-so-quic-a-performance-study-of-dash-over-quic/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.c68298aa5045798fc8b25f8a2882169222cb63a98774faa68088de5b1d7b2bfb.css" integrity="sha256-xoKYqlBFeY/Isl&#43;KKIIWkiLLY6mHdPqmgIjeWx17K/s=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
        onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://jonathan-tw.github.io/img/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://jonathan-tw.github.io/img/favicon.ico">
<link rel="icon" type="image/png" sizes="32x32" href="https://jonathan-tw.github.io/img/favicon.ico">
<link rel="apple-touch-icon" href="https://jonathan-tw.github.io/img/favicon.ico">
<link rel="mask-icon" href="https://jonathan-tw.github.io/img/favicon.ico">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = ""; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<meta property="og:title" content="(2017 NOSSDAV) Not so QUIC A Performance Study of DASH over QUIC" />
<meta property="og:description" content="Summary QUICä¸åŠTCPåœ¨DASHçš„è¡¨ç¾ï¼Œç”±æ–¼å¤§å¤šæ•¸ABR algorighméƒ½ç¶“éå„ªåŒ–èˆ‡TCPé…åˆä½¿ç”¨ï¼Œå› æ­¤æ²’æœ‰å……åˆ†åˆ©ç”¨QUICæä¾›çš„åŠŸèƒ½ã€‚ Problem statement What is the impact of QUIC on QoE? How should adaptive bitrate streaming be built to leverage the benefits provided by QUIC? Research objectives A Performance Study and future work Methods we studied QoE performance of different DASH quality adaptation algorithms that are either solely based on the playout buffer filling, or on the video segment download rate, or on both. DASH quality adaptation algorithms that are mainly categorized as" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jonathan-tw.github.io/posts/2017-nossdav-not-so-quic-a-performance-study-of-dash-over-quic/" />
<meta property="og:image" content="https://i.imgur.com/hgG8Fy8.png" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-13T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-06-14T00:00:00+00:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://i.imgur.com/hgG8Fy8.png" />
<meta name="twitter:title" content="(2017 NOSSDAV) Not so QUIC A Performance Study of DASH over QUIC"/>
<meta name="twitter:description" content="Summary QUICä¸åŠTCPåœ¨DASHçš„è¡¨ç¾ï¼Œç”±æ–¼å¤§å¤šæ•¸ABR algorighméƒ½ç¶“éå„ªåŒ–èˆ‡TCPé…åˆä½¿ç”¨ï¼Œå› æ­¤æ²’æœ‰å……åˆ†åˆ©ç”¨QUICæä¾›çš„åŠŸèƒ½ã€‚ Problem statement What is the impact of QUIC on QoE? How should adaptive bitrate streaming be built to leverage the benefits provided by QUIC? Research objectives A Performance Study and future work Methods we studied QoE performance of different DASH quality adaptation algorithms that are either solely based on the playout buffer filling, or on the video segment download rate, or on both. DASH quality adaptation algorithms that are mainly categorized as"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [

        {
          "@type": "ListItem",
          "position":  2 ,
          "name": "ğŸ“š Posts",
          "item": "https://jonathan-tw.github.io/posts/"
        }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "(2017 NOSSDAV) Not so QUIC A Performance Study of DASH over QUIC",
      "item": "https://jonathan-tw.github.io/posts/2017-nossdav-not-so-quic-a-performance-study-of-dash-over-quic/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "(2017 NOSSDAV) Not so QUIC A Performance Study of DASH over QUIC",
  "name": "(2017 NOSSDAV) Not so QUIC A Performance Study of DASH over QUIC",
  "description": "Summary QUICä¸åŠTCPåœ¨DASHçš„è¡¨ç¾ï¼Œç”±æ–¼å¤§å¤šæ•¸ABR algorighméƒ½ç¶“éå„ªåŒ–èˆ‡TCPé…åˆä½¿ç”¨ï¼Œå› æ­¤æ²’æœ‰å……åˆ†åˆ©ç”¨QUICæä¾›çš„åŠŸèƒ½ã€‚ Problem statement What is the impact of QUIC on QoE? How should adaptive bitrate streaming be built to leverage the benefits provided by QUIC? Research objectives A Performance Study and future work Methods we studied QoE performance of different DASH quality adaptation algorithms that are either solely based on the playout buffer filling, or on the video segment download rate, or on both. DASH quality adaptation algorithms that are mainly categorized as",
  "keywords": [
    ""
  ],
  "articleBody": "Summary QUICä¸åŠTCPåœ¨DASHçš„è¡¨ç¾ï¼Œç”±æ–¼å¤§å¤šæ•¸ABR algorighméƒ½ç¶“éå„ªåŒ–èˆ‡TCPé…åˆä½¿ç”¨ï¼Œå› æ­¤æ²’æœ‰å……åˆ†åˆ©ç”¨QUICæä¾›çš„åŠŸèƒ½ã€‚\nProblem statement What is the impact of QUIC on QoE? How should adaptive bitrate streaming be built to leverage the benefits provided by QUIC? Research objectives A Performance Study and future work Methods we studied QoE performance of different DASH quality adaptation algorithms that are either solely based on the playout buffer filling, or on the video segment download rate, or on both. DASH quality adaptation algorithms that are mainly categorized as throughputand/or playout buffer-based techniques. BB2-2: based on buffer. map current buffer occupancy to a quality bitrate.\nthe client tends to download a quality that is higher than the measured rate in order to provide the user with maximum average quality.\nSQUAD: based on rate that is specifically optimized for variations in TCP download rates. BOLA: based on both.\nEvaluation How does the author appraise their methodology?\nTestbed (Parallel Server / Single Server) bottleneck link of 10Mbps / Python-based DASH player / Caddy server Internet (wifi on campus / wifi on residential / wired campus Network ) with 17 bitrates ranging from 100Kbps on Aamazon EC2 How is the experiment set up?\nAverage Quality Bitrate (AQB) = Chosen Rate\nNumber of Quality Switches (#QS)\nSpectrum (H): A lower H indicates a better QoE. (bitrateè®ŠåŒ–çš„é›†ä¸­åº¦é‡)\nRebuffering Ratio:\n$$ \\frac {Total;length - video;length } {video;length } $$\nWe investigated different QoE performance metrics such as the average quality bitrate, a measure of quality variations (denoted spectrum) (å½±ç‰‡è³ªé‡å·®ç•°-é »è­œ) and the average video stalling duration. Testbed BBA-2 seems to benefit from using QUIC to download segments because of the slow-start or initial phase of the algorithm.\nthe client tends to download a quality that is higher than the measured rate in order to provide the user with maximum average quality. åªæœ‰è¼ƒå¤§çš„RTTæ™‚ï¼Œæœƒé€ æˆbufferä¸è¶³ï¼Œé–“æ¥ä½¿å¾—BBA-2 clientåˆ‡æ›åˆ°lower quality.\n(rule-of-thumb)bandwidth-delay product(BDP): B = C * RTT (receive bufferæ”¶åˆ°çš„å¤§å°ï¼Œå·²å‚³é€ä½†å°šæœªç¢ºèªçš„è³‡æ–™)\nInternet Wifi significantly worse quality bitrate: QUIC is likely to be competing with more TCP streams than other QUIC streams, it takes longer than TCP to fetch the same segments Future Work HOL blocking (Multiplexing,Multi-Path)\nPacing\nIf a client requests multiple qualities for a single segment, the server could pace the streams to deliver segments at regular intervals instead of using AIMD. å¦‚æœå–®å€‹ç¶²æ®µæä¾›å¤šç¨®è³ªé‡ï¼Œå®šæœŸæ™‚é–“ä¸‹ï¼Œä»¥streamçš„é€Ÿåº¦ä¸‹å»äº¤ä»˜segmentsè€Œä¸æ˜¯AIMD\nIf a client requests multiple segments over the same connection via multiple streams the server could implement a decreasing pacing rate for segments requested depending on how soon they are required for playback. clientå¦‚æœåœ¨å¤šå€‹streamä¸­è«‹æ±‚å¤šå€‹segmentï¼ŒServerå¯ä»¥æ ¹æ“šã€Œè«‹æ±‚çš„segmentã€éœ€è¦å¤šé•·æ™‚é–“ä¾†é™ä½pacing rate\nAIMD -\u003e TCPæ“å¡æ§åˆ¶çš„æ–¹æ³•\nEliminate Congestion Control Redundancy two congestion on client; in trans/ in DASH algo\nABR clients can disable congestion control in the QUIC transport layer and continue to use their existing congestion control\nQUIC provides the benefits of pacing and assistance for loss recovery in the form of NACKs\nRTP does that.\nConclusion we find through testbed and Internet measurements that QUIC does not provide a boost to current DASH algorithms but instead a degradation in the chosen quality bitrates. Although we observe a lower magnitude of quality variations (è¼ƒä½çš„è³ªé‡è®ŠåŒ–å¹…åº¦), the degradation of streamed quality bitrate with the use of QUIC is detrimental to overall QoE References ABR work/ congestion control / congestion avoidance\n[14]: Tcp hollywood: An unordered, time-lined, tcp for networked multimedia applications (2016)\nTCP Hollywood,a TCP variant, which implements out-of-order delivery and inconsistent retransmissions in order to improve good-put of video streaming applications\n[21]: Media qoe enhancement with quic (2016)\na new congestion control mechanism using QUIC that aggressively varies download rate according to a buffer-based priority level assigned by the ABR streaming client\n[4]: ABR protocol over UDP (2003)\nthe authors employ a form of congestion avoidance where the sending rate at the server is increased by a single packet for every RTT measurement.This design is different from the AIMD congestion control employed by TCP and QUIC since it eliminates the effect of slow start and attempts to provide an accurate estimate of the available bandwidth in the network. Some drawbacks of this approach are the requirement of two UDP sockets for every connection and the use of Berkeley Packet Filters to collect timestamps at the server and client for every video stream, thus, reducing both performance and scalability of the system\n",
  "wordCount" : "977",
  "inLanguage": "en",
  "image":"https://i.imgur.com/hgG8Fy8.png","datePublished": "2023-06-13T00:00:00Z",
  "dateModified": "2023-06-14T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Jonathan"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://jonathan-tw.github.io/posts/2017-nossdav-not-so-quic-a-performance-study-of-dash-over-quic/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Jonathan's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://jonathan-tw.github.io/img/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>



<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://jonathan-tw.github.io" accesskey="h" title="Jonathan&#39;s Blog (Alt + H)">
            <img src="https://jonathan-tw.github.io/img/favicon.ico" alt="logo" aria-label="logo"
                 height="35">Jonathan&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://jonathan-tw.github.io/" title="ğŸ  Home">
                <span>ğŸ  Home</span>
                </a>
            </li>
            <li>
                <a href="https://jonathan-tw.github.io/posts" title="ğŸ“š Posts">
                <span>ğŸ“š Posts</span>
                </a>
            </li>
            <li>
                <a href="https://jonathan-tw.github.io/tags" title="ğŸ§© Tags">
                <span>ğŸ§© Tags</span>
                </a>
            </li>
            <li>
                <a href="https://jonathan-tw.github.io/archives/" title="ğŸ“… Archive">
                <span>ğŸ“… Archive</span>
                </a>
            </li>
            <li>
                <a href="https://jonathan-tw.github.io/search" title="ğŸ” Search (Alt &#43; /)" accesskey=/>
                <span>ğŸ” Search</span>
                </a>
            </li>
            <li>
                <a href="https://coding-interview.netlify.app/" title="ğŸ‘¨â€ğŸ’» Jonathan&#39;s Coding Interview">
                <span>ğŸ‘¨â€ğŸ’» Jonathan&#39;s Coding Interview</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main page">
<article class="post-single">
    <div id="single-content">
        <header class="post-header">
            <div class="breadcrumbs"><a href="https://jonathan-tw.github.io">Home</a>&nbsp;Â»&nbsp;<a href="https://jonathan-tw.github.io/posts/">ğŸ“š Posts</a></div>
            <h1 class="post-title">
                (2017 NOSSDAV) Not so QUIC A Performance Study of DASH over QUIC
            </h1>
            <div class="post-meta">Created:&nbsp;<span title='2023-06-13 00:00:00 +0000 UTC'>2023-06-13</span>&nbsp;|&nbsp;Upated:&nbsp;2023-06-14&nbsp;|&nbsp;Count words:&nbsp;977&nbsp;|&nbsp;Reading time:&nbsp;2 mins



                &nbsp;|&nbsp;Tags: &nbsp;
                <ul class="post-tags-meta">
                    <a href="https://jonathan-tw.github.io/tags/paper/">paper</a>
                    <a href="https://jonathan-tw.github.io/tags/quic/">ã€quic</a>
                </ul>
                

            
            </span>

</div>
        </header> 
<figure class="entry-cover1"><img loading="lazy" src="https://i.imgur.com/hgG8Fy8.png" alt="">
        
</figure>
        <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#summary" aria-label="Summary">Summary</a></li>
                <li>
                    <a href="#problem-statement" aria-label="Problem statement">Problem statement</a></li>
                <li>
                    <a href="#research-objectives" aria-label="Research objectives">Research objectives</a></li>
                <li>
                    <a href="#methods" aria-label="Methods">Methods</a></li>
                <li>
                    <a href="#evaluation" aria-label="Evaluation">Evaluation</a><ul>
                        
                <li>
                    <a href="#testbed" aria-label="Testbed">Testbed</a></li>
                <li>
                    <a href="#internet" aria-label="Internet">Internet</a></li>
                <li>
                    <a href="#future-work" aria-label="Future Work">Future Work</a></li></ul>
                </li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a></li>
                <li>
                    <a href="#references" aria-label="References">References</a>
                </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
            const id = encodeURI(element.getAttribute('id')).toLowerCase();
            if (element === activeElement){
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
            } else {
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
            }
        })
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
        
        <div class="post-content"><h2 id="summary">Summary<a hidden class="anchor" aria-hidden="true" href="#summary">#</a></h2>
<p>QUICä¸åŠTCPåœ¨DASHçš„è¡¨ç¾ï¼Œç”±æ–¼å¤§å¤šæ•¸ABR algorighméƒ½ç¶“éå„ªåŒ–èˆ‡TCPé…åˆä½¿ç”¨ï¼Œå› æ­¤æ²’æœ‰å……åˆ†åˆ©ç”¨QUICæä¾›çš„åŠŸèƒ½ã€‚</p>
<h2 id="problem-statement">Problem statement<a hidden class="anchor" aria-hidden="true" href="#problem-statement">#</a></h2>
<ul>
<li>What is the impact of QUIC on QoE?</li>
<li>How should adaptive bitrate streaming be built to leverage the benefits provided by QUIC?</li>
</ul>
<h2 id="research-objectives">Research objectives<a hidden class="anchor" aria-hidden="true" href="#research-objectives">#</a></h2>
<ul>
<li>A Performance Study and future work</li>
</ul>
<h2 id="methods">Methods<a hidden class="anchor" aria-hidden="true" href="#methods">#</a></h2>
<ul>
<li>we studied QoE performance of different DASH quality adaptation algorithms that are either solely based on the <strong>playout buffer filling</strong>, or on the <strong>video segment download rate</strong>, or on <strong>both</strong>.</li>
<li>DASH quality adaptation algorithms that are mainly categorized as throughputand/or playout buffer-based techniques.</li>
</ul>
<p>BB2-2: based on buffer. map current buffer occupancy to a quality bitrate.</p>
<blockquote>
<p>the client tends to download a quality that is higher than the measured rate in order to provide the user with maximum average quality.</p>
</blockquote>
<p>SQUAD: based on rate that is specifically optimized for variations in TCP download rates.
BOLA: based on both.</p>
<h2 id="evaluation">Evaluation<a hidden class="anchor" aria-hidden="true" href="#evaluation">#</a></h2>
<p>How does the author appraise their methodology?</p>
<ol>
<li>Testbed (Parallel Server / Single Server)
bottleneck link of 10Mbps / Python-based DASH player / Caddy server</li>
<li>Internet (wifi on campus / wifi on residential / wired campus Network )
with 17 bitrates ranging from 100Kbps on Aamazon EC2</li>
</ol>
<p>How is the experiment set up?</p>
<ol>
<li>
<p>Average Quality Bitrate (AQB) = Chosen Rate</p>
</li>
<li>
<p>Number of Quality Switches (#QS)</p>
</li>
<li>
<p>Spectrum (H): A lower H indicates a better QoE. (bitrateè®ŠåŒ–çš„é›†ä¸­åº¦é‡)</p>
</li>
<li>
<p>Rebuffering Ratio:</p>
<p>$$
\frac {Total;length - video;length } {video;length }
$$</p>
</li>
</ol>
<ul>
<li>We investigated different QoE performance metrics such as the <strong>average quality bitrate</strong>, a measure of <strong>quality variations (denoted spectrum)</strong> (å½±ç‰‡è³ªé‡å·®ç•°-é »è­œ) and the <strong>average video stalling duration</strong>.</li>
</ul>
<h3 id="testbed">Testbed<a hidden class="anchor" aria-hidden="true" href="#testbed">#</a></h3>
<p><img loading="lazy" src="https://i.imgur.com/WChgkik.png" alt="image-20210504142314652"  />
</p>
<p><img loading="lazy" src="https://i.imgur.com/b3IidlT.png" alt="image-20210504141515242"  />
</p>
<blockquote>
<p>BBA-2 seems to benefit from using QUIC to download segments because of the slow-start or initial phase of the algorithm.</p>
<blockquote>
<p>the client tends to download a quality that is higher than the measured rate in order to provide the user with maximum average quality.
åªæœ‰è¼ƒå¤§çš„RTTæ™‚ï¼Œæœƒé€ æˆbufferä¸è¶³ï¼Œé–“æ¥ä½¿å¾—BBA-2 clientåˆ‡æ›åˆ°lower quality.</p>
</blockquote>
</blockquote>
<p><strong>(<em>rule-of-thumb</em>)bandwidth-delay product(BDP): B = C * RTT (receive bufferæ”¶åˆ°çš„å¤§å°ï¼Œå·²å‚³é€ä½†å°šæœªç¢ºèªçš„è³‡æ–™)</strong></p>
<h3 id="internet">Internet<a hidden class="anchor" aria-hidden="true" href="#internet">#</a></h3>
<p><img loading="lazy" src="https://i.imgur.com/xtzp6MI.png" alt="image-20210504152404870"  />
</p>
<ol>
<li>Wifi significantly worse quality bitrate: QUIC is likely to be competing with more TCP streams than other QUIC streams, it takes longer than TCP to fetch the same segments</li>
</ol>
<h3 id="future-work">Future Work<a hidden class="anchor" aria-hidden="true" href="#future-work">#</a></h3>
<ol>
<li>
<p>HOL blocking (Multiplexing,Multi-Path)</p>
</li>
<li>
<p>Pacing</p>
<ol>
<li>
<p>If a client requests multiple qualities for a single segment, the server could pace the streams to deliver segments at regular intervals instead of using AIMD.
å¦‚æœå–®å€‹ç¶²æ®µæä¾›å¤šç¨®è³ªé‡ï¼Œå®šæœŸæ™‚é–“ä¸‹ï¼Œä»¥streamçš„é€Ÿåº¦ä¸‹å»äº¤ä»˜segmentsè€Œä¸æ˜¯<strong>AIMD</strong></p>
</li>
<li>
<p>If a client requests multiple segments over the same connection via multiple streams the server could implement a decreasing pacing rate for segments requested depending on how soon they are required for playback.
clientå¦‚æœåœ¨å¤šå€‹streamä¸­è«‹æ±‚å¤šå€‹segmentï¼ŒServerå¯ä»¥æ ¹æ“šã€Œè«‹æ±‚çš„segmentã€éœ€è¦å¤šé•·æ™‚é–“ä¾†é™ä½pacing rate</p>
<blockquote>
<p>AIMD -&gt; TCPæ“å¡æ§åˆ¶çš„æ–¹æ³•</p>
</blockquote>
</li>
<li>
<p>Eliminate Congestion Control Redundancy
two congestion on client; in trans/ in DASH algo</p>
<blockquote>
<p>ABR clients can disable congestion control in the QUIC transport layer and continue to use their existing congestion control</p>
</blockquote>
<p><strong>QUIC provides the benefits of pacing and assistance for loss recovery in the form of NACKs</strong></p>
<blockquote>
<p>RTP does that.</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<ul>
<li>we find through testbed and Internet measurements that <strong>QUIC does not provide a boost to current DASH algorithms but instead a degradation in the chosen quality bitrates</strong>.</li>
<li>Although we observe a lower magnitude of quality variations (è¼ƒä½çš„è³ªé‡è®ŠåŒ–å¹…åº¦), the degradation of streamed quality bitrate with the use of QUIC is detrimental to overall QoE</li>
</ul>
<h2 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h2>
<p>ABR work/ congestion control / congestion avoidance</p>
<blockquote>
<p>[14]: Tcp hollywood: An unordered, time-lined, tcp for networked multimedia applications (2016)</p>
<blockquote>
<p>TCP Hollywood,a TCP variant, which implements out-of-order delivery and inconsistent retransmissions in order to improve good-put of video streaming applications</p>
</blockquote>
</blockquote>
<blockquote>
<p>[21]: Media qoe enhancement with quic (2016)</p>
<blockquote>
<p>a new congestion control mechanism using QUIC that aggressively varies download rate according to a buffer-based priority level assigned by the ABR streaming client</p>
</blockquote>
</blockquote>
<blockquote>
<p>[4]: ABR protocol over UDP (2003)</p>
<blockquote>
<p>the authors employ a form of congestion avoidance where the sending rate at the server is increased by a single packet for every RTT measurement.This design is different from the AIMD congestion control employed by TCP and QUIC since it eliminates the effect of slow start and attempts to provide an accurate estimate of the available bandwidth in the network. Some drawbacks of this approach are the requirement of two UDP sockets for every connection and the use of Berkeley Packet Filters to collect timestamps at the server and client for every video stream, thus, reducing both performance and scalability of the system</p>
</blockquote>
</blockquote>


        </div>

        <footer class="post-footer">
            
<nav class="paginav">
  <a class="prev" href="https://jonathan-tw.github.io/posts/2019-ieee-improving-performance-of-quic-in-wifi-2018-conext-the-quic-fix-for-optimal-video-streaming/">
    <span class="title">Â« Prev</span>
    <br>
    <span>(2019 IEEE) Improving Performance of QUIC in WiFi &amp; (2018 CoNEXT) The QUIC Fix for Optimal Video Streaming</span>
  </a>
  <a class="next" href="https://jonathan-tw.github.io/posts/2020-ieee-does-quic-suit-well-with-modern-adaptive-bitrate-streaming-techniques/">
    <span class="title">Next Â»</span>
    <br>
    <span>(2020 IEEE) Does QUIC Suit Well With Modern Adaptive Bitrate Streaming Techniques?</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share (2017 NOSSDAV) Not so QUIC A Performance Study of DASH over QUIC on twitter"
       href="https://twitter.com/intent/tweet/?text=%282017%20NOSSDAV%29%20Not%20so%20QUIC%20A%20Performance%20Study%20of%20DASH%20over%20QUIC&amp;url=https%3a%2f%2fjonathan-tw.github.io%2fposts%2f2017-nossdav-not-so-quic-a-performance-study-of-dash-over-quic%2f&amp;hashtags=paper%2cquic">
    <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share (2017 NOSSDAV) Not so QUIC A Performance Study of DASH over QUIC on linkedin"
       href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fjonathan-tw.github.io%2fposts%2f2017-nossdav-not-so-quic-a-performance-study-of-dash-over-quic%2f&amp;title=%282017%20NOSSDAV%29%20Not%20so%20QUIC%20A%20Performance%20Study%20of%20DASH%20over%20QUIC&amp;summary=%282017%20NOSSDAV%29%20Not%20so%20QUIC%20A%20Performance%20Study%20of%20DASH%20over%20QUIC&amp;source=https%3a%2f%2fjonathan-tw.github.io%2fposts%2f2017-nossdav-not-so-quic-a-performance-study-of-dash-over-quic%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share (2017 NOSSDAV) Not so QUIC A Performance Study of DASH over QUIC on reddit"
       href="https://reddit.com/submit?url=https%3a%2f%2fjonathan-tw.github.io%2fposts%2f2017-nossdav-not-so-quic-a-performance-study-of-dash-over-quic%2f&title=%282017%20NOSSDAV%29%20Not%20so%20QUIC%20A%20Performance%20Study%20of%20DASH%20over%20QUIC">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share (2017 NOSSDAV) Not so QUIC A Performance Study of DASH over QUIC on facebook"
       href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjonathan-tw.github.io%2fposts%2f2017-nossdav-not-so-quic-a-performance-study-of-dash-over-quic%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share (2017 NOSSDAV) Not so QUIC A Performance Study of DASH over QUIC on whatsapp"
       href="https://api.whatsapp.com/send?text=%282017%20NOSSDAV%29%20Not%20so%20QUIC%20A%20Performance%20Study%20of%20DASH%20over%20QUIC%20-%20https%3a%2f%2fjonathan-tw.github.io%2fposts%2f2017-nossdav-not-so-quic-a-performance-study-of-dash-over-quic%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share (2017 NOSSDAV) Not so QUIC A Performance Study of DASH over QUIC on telegram"
       href="https://telegram.me/share/url?text=%282017%20NOSSDAV%29%20Not%20so%20QUIC%20A%20Performance%20Study%20of%20DASH%20over%20QUIC&amp;url=https%3a%2f%2fjonathan-tw.github.io%2fposts%2f2017-nossdav-not-so-quic-a-performance-study-of-dash-over-quic%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

        </footer>
    </div>
</article>
</main>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<footer class="footer">
    <span>
        Copyright
        &copy;
        2023-2023
        <a href="https://jonathan-tw.github.io" style="color:#939393;">Jonathan&#39;s Blog</a>
        All Rights Reserved
    </span>

    <a href="https://beian.miit.gov.cn/" target="_blank" style="color:#939393;"></a>&nbsp;


    <span id="busuanzi_container">
        <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
        Viewers: <span id="busuanzi_value_site_uv"></span>
        Views: <span id="busuanzi_value_site_pv"></span>
    </span>

</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
    document.addEventListener('scroll', function (e) {
        const readProgress = document.getElementById("read_progress");
        const scrollHeight = document.documentElement.scrollHeight;
        const clientHeight = document.documentElement.clientHeight;
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        
        readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
    })
</script><script>

  let detail = document.getElementsByClassName('details')
 
  details = [].slice.call(detail);
 
  for (let index = 0; index < details.length; index++) {
 
  let element = details[index]
 
  const summary = element.getElementsByClassName('details-summary')[0];
 
  if (summary) {
 
  summary.addEventListener('click', () => {
 
  element.classList.toggle('open');
 
  }, false);
 
  }
 
  }
 
 </script>
 

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    let mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 400 || document.documentElement.scrollTop > 400) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                let text = codeblock.textContent +
                    '\r\nâ€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\r\n' +
                    'ç‰ˆæƒå£°æ˜ï¼šæœ¬æ–‡ä¸ºã€Œ' + "Jonathan's Blog"
                +'ã€çš„åŸåˆ›æ–‡ç« ï¼Œéµå¾ªCC 4.0 BY-SAç‰ˆæƒåè®®ï¼Œè½¬è½½è¯·é™„ä¸ŠåŸæ–‡å‡ºå¤„é“¾æ¥åŠæœ¬å£°æ˜ã€‚' +
                '\r\nåŸæ–‡é“¾æ¥ï¼š' + location.href;
                navigator.clipboard.writeText(text);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {
            }
            ;
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild === container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName === "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>

<script src="https://code.jquery.com/jquery-1.12.4.min.js"></script>
<script>
    $("code[class^=language] ").on("mouseover", function () {
        if (this.clientWidth < this.scrollWidth) {
            $(this).css("width", "135%")
        }
    }).on("mouseout", function () {
        $(this).css("width", "100%")
    })
</script>
</body>

</html>
