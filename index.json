[{"content":"Lecture 2 - Asynchronous I/O Programming Models\nConcurrency (Asynchronous I/O = cooperative multitasking) Multiple tasks have the ability to run in an overlapping manner Concurrency does not imply parallelism! Multiprocessing CPU-bounded tasks Multithreading I/O bound tasks It uses preemtive multitasking Promise object:\nan async object that be returned by the async function. An object representing completion or failure of an asynchronous operation. Await function:\nmakes program to wait until the promise is resolved or rejected can only be usded inside async function Lecture 3 - Cloud Architectures Cloud Computing Concepts On-demand and self-service (當需要資源時才被提供,自動化) Resources are provisioned as they are requested and when they are required ‒ No human interaction, automatic No human interaction, automatic Board network access (資源可被網路取得) Capabilities are available over the network Resource pooling (資源根據需求再提供,硬體配置被mutiple tenant共用) Resourcces are dynamically assigned/re-assigned according to demand Provider\u0026rsquo;s computing resources reused by multiple tenants Computing resources: CPU, memory, storage, network Scalability and elasticity (資源根據需求擴大或縮減) Infrastructure may grow and shrink according to needs Automatic or manual Measured service (資源可被控管) Resource usage can be monitored, controlled and reported Pay-per-use (當消費者使用資源時才付費) Consumers only pay for resources when they use them Multitenancy: Architectural approach where resources are shared between multiple tenants or consumers Infrastructure as Code: Version control, team development, scripting, etc.\nTerraform:\nHigher-level abstraction of the datacenter and associated services Supports many service providers: Google, Microsoft, Oracle, AWS VCN = a private network in a single region in which your instances reside\nLecture 4 - Cloud Native and Microservices Microservices: applications as independenly deployable services\nLoosely coupled: Integrated using well-defined interfaces Technology-agnostic protocols: HTTP, they use REST architecture Independently deployable and easy to replace: A change in small part requires to redeploy only that part Implemented using different technologies: PL, databases Container Dockerfile is a script that creates a new image A line in the Dockerfile will create an intermediary layer docker build -t tomvit/httpd:v1 If processing fails at some step, all preceeding steps will be loaded from the cache on the next run.\nNetworking and Linking:\nbridge – container can access host\u0026rsquo;s network (default) host – all host\u0026rsquo;s network interfaces will be available in the container none – container will be placed on its own network and no network interfaces will be configured. Data Volume:\nA directory that bypass the union file system Data volumes can be shared and reused among containers Data volume persists even if the container is deleted It is possible to mount a shared sotrage volume as a data volue by using a volume plugin to mount e.g. NFS Lecture 5 - Browser Networking Network security\nConnection limits Request formatting and response processing TLS negotiation Same-origin policy XMLHttpRequest (XHR) basis for AJAX → Asynchronous JavaScript and XML Security Scripting Attacks CSRF(Cross-site request forgery) 利用Session未過期的特性，冒沖使用者身份來做惡意攻擊\nCSRF的攻擊流程是利用使用者剛使用完某服務後不久Session未過期的時間內，誘導使用者點擊惡意連結來冒充使用者的身份發送非本意的請求，例如使用者剛登入網銀沒多久後收到一個連結，點開來後才發現是一個轉帳的api將使用者的戶頭的錢轉到指定戶頭去\n舉例來說，誘導使用者拜訪惡意網站，然後在網站內的img src塞有CSRF 漏洞的api，只要Session沒過期，就可以成功攻擊，當然那是api 是GET請求狀況. 預防方法:\n檢查Referer: Header的referer欄位記錄著來源的domain，只要是不同domain就擋，簡單直接，但可惜的是有些瀏覽器不帶referer XSS (Cross-Site-Scripting) 將惡意程式碼植入網站內，讓網站去執行惡意程式碼來達到獲取敏感資料的目的\nXSS: 將惡意程式碼植入網站內，讓網站去執行惡意程式碼來達到獲取敏感資料的目的 儲存型XSS: XSS攻擊常見於網站有讓使用者輸入的部分(如表單，回覆留言等等)，攻擊者輸入惡意程式碼後送出，來注入惡意程式到Database，來達到攻擊的目的，因為攻擊成功後只有在Database看得出來，且每個使用者對會受到影響，因此殺傷力最大\nEx. 假如社群網站回覆留言時輸入 且網站沒有做任何XSS防禦就顯示user的留言，則網站就會顯示出惡意的通 預防方法:\n最重要的邏輯是不能相信使用者的輸入，在輸入時檢查或是輸出時做檢查，例如將使用者輸入的值轉成純文字再輸出，在前端框架下(ex. Vue.js)，即會對所有的data做XSS的檢查將其轉換為純文字 Cross-origin Resource Sharing Protocol (CORS) Allow for cross-site HTTP requests HTTP requests for resources from a different domain than the domain of the resource making the request. JSON and JSONP ajax請求受同源策略影響，不允許進行跨域請求，而script標籤src屬性中的鏈接卻可以訪問跨域的js腳本，利用這個特性，服務端不再返回JSON格式的數據，而是返回一段調用某個函數的js代碼，在src中進行了調用，這樣實現了跨域\nService that supports JSONP allows to specify a query string parameter for a wrapper function to load the data in JavaScript code otherwise the data cannot be used in JavaScript they\u0026rsquo;re loaded into the memory but assigned to nothing A kind of workaround for the same origin policy Resource Format GET DELETE http://company.at/customers XML AJAX (1) AJAX (2) http://company.at/suppliers JSON AJAX, JSONP (3) AJAX (4) http://weather.at/innsbruck XML AJAX-CORS (5) AJAX-CORS (6) http://people.at/students JSON AJAX-CORS, JSONP (7) AJAX-CORS (8) http://people.at/{dob}/contact VCARD AJAX-CORS (9) AJAX-CORS (10) res.writeHead(200, { 'Content-Type': 'Application/json', 'Access-Control-Allow-Origin': '*' }); Lecture 6 - Security 驗證（Authentication）是證明身分（identity）的機制，例如: authenticate(name, passwd)方法定義了如何使用name與passwd進行驗證。此外，驗證方式不僅是基於名稱及密碼，也有可能基於憑證（Certificate）之類的機制。一旦caterpillar通過驗證，就可以看到訊息，也就是說，另外有個機制決定訊息資源可否授權觀看，就像授權（Authorization）定義了身分與資源之間的存取控制規則，例如，if(authorized()) { show(\u0026ldquo;message\u0026rdquo;); }這個流程，定義了\u0026quot;message\u0026quot;是否可以顯示。\nStandard: HTTP authentication\nHTTP defines two options Basic Access Authentication Digest Access Authentication Basic authentication HTTP Basic Authentication為一簡單的HTTP請求認證方法，用來保護server端的資源。當client端對server發起請求的同時必須提供帳號(user-id)及密碼(password)讓server端驗證，只有通過驗證才能取得資源。\nClient提供Basic Authentication請求的帳號密碼的方式為，\n在HTTP Request Headers加入key=Authorization，value=Basic \u0026lt;basic-credentials\u0026gt;。\nBasic為Basic Authentication規範的名稱，固定加在前頭。\u0026lt;basic-credentials\u0026gt;為Basic Authentication的憑證，其為以Base64 encode對user-id:password的編碼。\n例如帳號為john，密碼為abc，則\u0026lt;basic-credentials\u0026gt;為以Base 64 encode對john:abc的編碼，也就是am9objphYmM=。\n因此對server資源發出請求時，在Request Headers加入以下欄位。\n1 Authentication: Basic am9objphYmM= A client may associate a valid credentials with realms such that it copies authorization information in requests for which server requires authentication (by WWW-Authenticate header) Credentials: credentials are base64 encoded (the format is: username:password) Digest Access Authentication No password between a client and a server but a hash value.\n[[開發者必備知識 - HTTP認證 (HTTP Authentication)]]\nTLS TLS provives message framing mechanism Every message is signed with Message Authentication Code (MAC) MAC hashes data in a message and combines the resulting hash with a key (negotiated during the TLS handshake) The result is a message authentication code sent with the message TLS and Proxy Servers:\nTLS Offloading: Inbound TLS connection, plain outbound connection ‒ Proxy can inspect messages\nTLS Bridging: Inbound TLS connection, new outbound TLS connection ‒ Proxy can inspect messages\nEnd-to-End TLS (TLS pass-through): TLS connection is passed-through the proxy - Proxy cannot inspect messages\nLoad balancer: Can use TLS offloading or TLS bridging ‒ Can use TLS pass-through with help of Server Name Indication (SNI)\nJSON Web Token (JWT) After user logs in, following requests contain JWT token.\n授權(Authorization)：這是很常見 JWT 的使用方式，例如使用者從 Client 端登入後，該使用者再次對 Server 端發送請求的時候，會夾帶著 JWT，允許使用者存取該 token 有權限的資源。單一登錄(Single Sign On)是當今廣泛使用 JWT 的功能之一，因為它的成本較小並且可以在不同的網域(domain)中輕鬆使用。 訊息交換(Information Exchange)：JWT 可以透過公鑰/私鑰來做簽章，讓我們可以知道是誰發送這個 JWT，此外，由於簽章是使用 header 和 payload 計算的，因此還可以驗證內容是否遭到篡改。 Open standard Mechanism to securely transmit information between parties as a JSON object Can be verified and trusted as it is digitally signed Basic concepts\nCompact → has a small size → can be transmitted via a URL, POST, HTTP header. Self-contained → payload contains all required user information. Oauth 2.0 OAuth 1.0 – first standard, security problems, quite complex OAuth 2.0 – new version, not backward compatibile with 1.0 request: client_id + and client_secret, and redirect_link. grant: code + client_id + client_secret + redirect_link + grant_type: \u0026ldquo;authorization_code\u0026rdquo; access token: JWT token jwt.decode(token) to get the data.\nResponse:\nSuccess – 200 OK. Error – 401 Unauthorized when token expires or the client hasn\u0026rsquo;t performed the authorization request. Refreshing a token:\nPOST request to the token endpoint with grant_type=refresh_token and the previously obtained value of refresh_token OpenID Protocol OpenID絕妙地解決了多個帳號同步問題 XRDS：一種基於XML的XRI資源描述符。它被設計用來提供關於XRI的可用的、描述性信息。在OpenID應用場合中，XRDS用來描述OpenID服務器，並且使用「priority」參數標識了用戶對服務器的優選順序。在下面的示例中，http://www.livejournal.com/users/frank具有最高的優先權（最低的數值）：\nLecture 7 - Protocols for the Realtime Web server is able to send pieces of response w/o terminating the conn.\nusing transfer-encoding header in HTTP 1.1 (Transfer-Encoding: chunked) Each chunk starts with hexadecimal value for length End of response is marked with the chunk length of 0 using End of File in HTTP 1.0 (server omits content-lenght in the response) Pushing – updates from the server (also called COMET)\nlong polling – server holds the request for some time streaming – server sends updates without closing the socket Server-Sent Events API to handle HTTP streaming in browsers by using DOM events transparent to underlying HTTP streaming mechanism Format response\u0026rsquo;s content-type must be text/event-stream ‒ every line starts with data:, event message terminates with 2 \\n chars. every message may have associated id (is optional) - When a connection is dropped EventSource will automatically reconnect: It may advertise the last seen message ID The client appends Last-Event-ID header in the reconnect request: The stream can be resumed and lost messages can be retransmitted. Cross-document messaging Lecture 8 - HTTP/2 communication is multiplexed within a single TCP connection Multiple requests and responses can be delivered in parallel, deliver lower page load times. Browser Request Prioritization Flow control Header compression Binary Framing Layer PUSH_PROMISE frames\nA singnal that the server intents to push resources to the client The client needs to know which resources the server intends to push to avoid creating duplicate requests for these resources. pushed resources must obey the same-origin policy Ref [1] CORS/CSRF/XSS 介紹與防禦方法 https://medium.com/%E7%A2%BC%E8%BE%B2%E8%83%8C%E5%8C%85%E5%AE%A2/cors-csrf-xss-%E4%BB%8B%E7%B4%B9%E8%88%87%E9%98%B2%E7%A6%A6%E6%96%B9%E6%B3%95-a1f5c55d96a1\n[2] js 跨域问题 https://zhuanlan.zhihu.com/p/583595367\n[3] 驗證與授權 https://www.ithome.com.tw/voice/134389\n[4] HTTP Basic Authentication https://matthung0807.blogspot.com/2020/04/http-basic-authentication.html\n[5] 是誰在敲打我窗？什麼是 JWT ？ https://5xruby.tw/posts/what-is-jwt\n","permalink":"https://jonathan-tw.github.io/posts/middleware-architectures-2-review/","summary":"Lecture 2 - Asynchronous I/O Programming Models Concurrency (Asynchronous I/O = cooperative multitasking) Multiple tasks have the ability to run in an overlapping manner Concurrency does not imply parallelism! Multiprocessing CPU-bounded tasks Multithreading I/O bound tasks It uses preemtive multitasking Promise object: an async object that be returned by the async function. An object representing completion or failure of an asynchronous operation. Await function: makes program to wait until the promise is resolved or rejected can only be usded inside async function Lecture 3 - Cloud Architectures Cloud Computing Concepts On-demand and self-service (當需要資源時才被提供,自動化) Resources are provisioned as they are requested and when they are required ‒ No human interaction, automatic No human interaction, automatic Board network access (資源可被網路","title":"(課程筆記)(CTU in Prague) Middleware architectures 2 Review"},{"content":"AJAX / XHR states / CORS / Data access Tasks Create a simple HTML page with an info text field and a single button Implement a JavaScript function which is triggered when the button is clicked The function should fetch relatively large file (e.g. 100-200MB) in the text field show following states: loading - when the open method was called loaded - when the send method was called downloading - while the data is being downloaded finished downloading - when the data has beeen downloaded you can use Promise, async/await Description AJAX overview:\nAsynchronous JavaScript and XML technique for creating better, faster, and more interactive web applications relies on XML, JSON, HTML, CSS and JavaScript AJAX is not a programming language Running this demo by using the jquery module to achieve the ajax request. Following the xhr state in https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readyState. The browser console would show the current XMLHttpRequest state when starting the server.\nDeal with the problem of CORS To deal with the CORS problem in the ajax request, I upload the large file to the Amazon S3 bucket and set the following json code to allow the local server accessing the remote resources.\nData access A company needs to design an AJAX aplication that will access various resources on the Web by using JavaScript code running in a browser. This application is not public and only internal employees of the company can use it. This application will be available at the address http://company.at. Following table shows a list of URL addresses of resources, their formats and HTTP methods that the application will use to access these resources. Add all possible access technologies to the table for methods GET and DELETE. Note: parameter {dob} means date of birth.\nResource Format GET DELETE http://company.at/customers XML AJAX (1) AJAX (2) http://company.at/suppliers JSON AJAX, JSONP (3) AJAX (4) http://weather.at/innsbruck XML AJAX-CORS (5) AJAX-CORS (6) http://people.at/students JSON AJAX-CORS, JSONP (7) AJAX-CORS (8) http://people.at/{dob}/contact VCARD AJAX-CORS (9) AJAX-CORS (10) (1) (2): Follow the Same Origin Policy (3) (4): JSONP only works on GET method (5) (6) (9) (10): Using CORS to deal with problem of different domain (7) (8): JSONP only works on GET method AJAX-CORS (add http header in server) 1 2 3 4 res.writeHead(200, { \u0026#39;Content-Type\u0026#39;: \u0026#39;Application/json\u0026#39;, \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39; }); AJAX-CORS (Using CORS Anywhere which adds CORS headers to the proxied request) Code (index.html) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt; HW2 - AJAX and XHR states \u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;Download File\u0026#34; onclick=\u0026#34;DownloadFile()\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value=\u0026#34;Ready to Download\u0026#34; id=\u0026#34;state\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;progressCounter\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;https://code.jquery.com/jquery-3.6.0.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var progressElem = $(\u0026#39;#progressCounter\u0026#39;); function DownloadFile() { var url = \u0026#34;https://mytest1.s3.amazonaws.com/file.bz2\u0026#34;; progressElem.text(url); $.ajax({ url: url, cache: false, xhr: function() { var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function() { if ( xhr.readyState == 1 ) { document.getElementById(\u0026#39;state\u0026#39;).setAttribute(\u0026#39;value\u0026#39;, \u0026#39;loading\u0026#39;); console.log(\u0026#34;Loading - when the open method was called\u0026#34;); } // if else if (xhr.readyState == 2) { if ( xhr.status == 200 ) { xhr.responseType = \u0026#34;blob\u0026#34;; } // if document.getElementById(\u0026#39;state\u0026#39;).setAttribute(\u0026#39;value\u0026#39;, \u0026#39;loaded\u0026#39;); console.log(\u0026#34;Loaded - when the send method was called\u0026#34;); } // else if else if ( xhr.readyState == 3 ) { document.getElementById(\u0026#39;state\u0026#39;).setAttribute(\u0026#39;value\u0026#39;, \u0026#39;downloading\u0026#39;); console.log(\u0026#34;downloading - while the data is being downloaded\u0026#34;); } // else if else { document.getElementById(\u0026#39;state\u0026#39;).setAttribute(\u0026#39;value\u0026#39;, \u0026#39;finished downloading\u0026#39;); console.log(\u0026#34;finished downloading - when the data has beeen downloade\u0026#34;); } // else }; // xhr.onready xhr.addEventListener(\u0026#34;progress\u0026#34;, function (evt) { console.log(evt.lengthComputable); if (evt.lengthComputable) { var percentComplete = evt.loaded / evt.total; progressElem.html(Math.round(percentComplete * 100) + \u0026#34;%\u0026#34;); } }, false); return xhr; }, success: function (data) { console.log(\u0026#34;nono\u0026#34;); // Convert the Byte Data to BLOB object. var blob = new Blob([data], { type: \u0026#34;application/octetstream\u0026#34; }); var link = window.URL.createObjectURL(blob); var a = $(\u0026#34;\u0026lt;a /\u0026gt;\u0026#34;); a.attr(\u0026#34;download\u0026#34;, \u0026#34;file.bz2\u0026#34;); // attributes,value a.attr(\u0026#34;href\u0026#34;, link); console.log(link); $(\u0026#34;body\u0026#34;).append(a); a[0].click(); $(\u0026#34;body\u0026#34;).remove(a); } }); }; // DownloadFile() \u0026lt;/script\u0026gt; \u0026lt;br\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Node.js server in Docker Tasks Implement a simple HTTP server in Node.js implement a \u0026ldquo;hello NAME\u0026rdquo; service endpoint request: \u0026ldquo;http://localhost:8080/John\u0026rdquo;, response \u0026ldquo;Hello John\u0026rdquo; Define an image Dockerfile, with the following specifications: build on a chosen node.js image the container should listen on port 8888 load the server implementation from a local directory run the server Create a docker image from the Dockerfile Create a container for the image tip: use the -p parameter to map public port to a private port inside the container (e.g. -p 8080:8888) Check if the container is running (docker container ls) Send several requests to the server running within the container you can use ping, curl or telnet for testing Stop the container Description Docker Overview:\npackage an application and its dependencies in a virtual container build, commit and share images based and primarily for Linux allows operating-system-level virtualization run isolated packages, also known, as containers Define an image Dockerfile and create a docker image 1 2 3 4 FROM --platform=linux/amd64 node:10-alpine COPY . /app WORKDIR /app CMD node /app/server.js 1 docker build -t hw3-docker . Create a container and run the curl. -p (Port mapping for the container and the host machine) 1 docker run -p 8080:8888 hw3-docker Docker advanced (Redis) Tasks Task 1: Start a docker container for a redis server: build on a chosen redis image redis run the server Task 2: Start a docker container for a redis client: build on a chosen redis image redis with the client insert some user info where key is the person name, and value is the address Task 3: Implement a simple HTTP server in Node.js implement a \u0026ldquo;http://localhost:8080/person/{person_name}/address\u0026rdquo; API, which returns the address of a person request: GET \u0026ldquo;http://localhost:8080/person/John/address\u0026rdquo;, response \u0026ldquo;Thakurova 9, 160 00, Prague\u0026rdquo; the server should fetch the data from a Redis server. Redis runs in a separate container than the node.js server! (see above). Task 4: Define an image Dockerfile (for the node.js server), with the following specifications: build on a chosen node.js image load the server implementation from a local directory run the server Create a docker image from the Dockerfile Create and run a container Test the server - it shoudl return the address for a person retrieved from the linked redis server container Description Task1 - Run the Redis Server in a container Redis-server stores the data from Redis-client, and can handle the request from the Node.js\n1 sudo docker run -p 6379:6379 --name redis-server -d redis Task 2 - Run the Redis client in a container Redis-client is linked to the Redis-server\n1 sudo docker run -it --link redis-server:redis --name redis-client -d redis Redis-client let user insert the data {kay,value} Task3 - Implement a simple HTTP server and run it on the host, and Node.js fetches the data from the Redis-server\nFailture 2022/04/03 - I faced the problem in the recent version of Redis, it seems that the problems are MAC docker or Redis version. https://stackoverflow.com/questions/71529419/redis-overiding-remote-host-in-nodejs I implemented the methods of docker-compose or link-container, but still encountered the connection refused problem. Success Must use redis version 3.0.2!!!!!!!!!\n1 npm install redis@3.0.2 Task4 - Docker-compose file\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # version of docker-compose version: \u0026#39;3.9\u0026#39; # \u0026#39;services\u0026#39; are equivalent to \u0026#39;containers\u0026#39; services: redis: image: \u0026#39;redis\u0026#39; ports: - \u0026#39;6379:6379\u0026#39; tnode11: image: \u0026#39;hw4-docker\u0026#39; # Specify an array of ports to map ports: - \u0026#39;8080:8888\u0026#39; Code (Redis server) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 const http = require(\u0026#39;http\u0026#39;); const redis = require(\u0026#39;redis\u0026#39;) var url = require(\u0026#34;url\u0026#34;); const server = http.createServer((req,res) =\u0026gt; { res.setHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;text/plain\u0026#39;); get_api_string = req.url.split(\u0026#39;/\u0026#39;); const client = redis.createClient({ host: \u0026#39;redis\u0026#39;, port: 6379 }) // get request from if ( get_api_string[1] == \u0026#34;person\u0026#34; \u0026amp;\u0026amp; get_api_string[3] == \u0026#34;address\u0026#34; ) { client.get(get_api_string[2], function (error, result) { console.log(\u0026#39;GET result -\u0026gt;\u0026#39; + result); if ( result == null ) res.write(\u0026#34;You must input the data to the redis-server from the redis client\u0026#34;); else res.write(\u0026#34;Hello \u0026#34; + result ); res.end(); }); } else { var echo_name = req.url.substring(1); res.write(\u0026#34;Hello \u0026#34; + echo_name); res.end(); } }); server.listen(8888, \u0026#39;0.0.0.0\u0026#39;, () =\u0026gt; { console.log(\u0026#34;listening for 8080\u0026#34;); }); HTTP/2 Push mechanism Tasks Implement an HTTP/2 push mechanism Implement a simple HTML page consisting of at least 3 additional resources (e.g. css, js, image, ..) Implement a simple http server serving the page via HTTP/2 When the html page is requested, push all those files together with the requested page Use http2 module Description HTTP/2 with the push method HTTP/2 without the push method The above results indicate that HTTP/2 using the push method is faster than the method without the push method. The key reason is the concurrency in the different types of files in one connection (Extend this concept to the QUIC protocol, fixing the HoL blocking problem).\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const sendFile = (stream, fileName) =\u0026gt; { const fd = fs.openSync(fileName, \u0026#34;r\u0026#34;); const stat = fs.fstatSync(fd); const headers = { \u0026#34;content-length\u0026#34;: stat.size, \u0026#34;last-modified\u0026#34;: stat.mtime.toUTCString(), \u0026#34;content-type\u0026#34;: mime.getType(fileName) }; stream.respondWithFD(fd, headers); // key point }; const pushFile = (stream, path, fileName) =\u0026gt; { stream.pushStream({ \u0026#34;:path\u0026#34;: path }, (err, pushStream) =\u0026gt; { if (err) { throw err; } sendFile(pushStream, fileName); }); }; Server-Sent Events Task Design and implement simple SSE server in Node.js and simple client in HTML/JavaScript.\nThe client connects to server and displays all incoming messages. The server sends every 2 seconds one message - e.g. one line of text file. Description Server-sent events are functions extended on top of HTTP. The server can actively send data to the client based on the new MIME type( text/event-stream ). Client: The URL is passed to EventSource() and creates a new EventSource object. onmessage() is triggered by receiving the data.\nServer: new MIME type(text/event-stream).\nCode 1 2 3 4 const message = `retry: ${refreshRate}\\nid:${id}\\ndata: ${data}\\n\\n`; res.write(message); }, refreshRate); retry: Specify the time interval for the browser to re-initiate the connection\nid: ID for each event-stream\ndata: the event data\n\u0026lsquo;\\n\u0026rsquo; gaps the indicator. \u0026lsquo;\\n\\n\u0026rsquo; switches the lines\nOAuth-Browser-Based-App Task Design and implement a simple OAuth - Browser-Based App. Browser-based apps run entirely in the browser after loading the source code from a web page.\nUse a simple server (https) for serving static content (html, js, …​). Configure any OAuth application of your choice. You can use any OAuth solution as authorization and resource server: Google, GitHub, …​ The app in browser connects to the authorization server and allows access to the resources. The app collects an presents in the browser any resource from the resource server using the provided code/token (e.g. list of contacts, files, messages, repositories, …​) Do not use any OAuth library (e.g. GoogleAuth, …​) Description Workflow:\nLog in to the Google cloud console to register a new project. Get the client_id and client_secret and set the redirect_link\nClient calls getGoogleAuthURL() to get the code from https://accounts.google.com/o/oauth2/v2/auth\nScope type: userinfo is the public data. If we want to leverage the common services, just like Google drive or photo\u0026hellip;, we need to add the test users until publishing the project.\nThe server posts the code with Axios to get the token from the https://oauth2.googleapis.com/token\nCall jwt.decode(token) to get the data\nCreate a new project in the Google cloud console Enter index.html to log in through ouath2 After logging, Authorization: OK. Print the callback data Code (OAuth server implement) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 const HTTP2_PORT = 3000; const http2 = require(\u0026#39;http2\u0026#39;); const mime = require(\u0026#39;mime\u0026#39;); const fs = require(\u0026#39;fs\u0026#39;); const url = require(\u0026#34;url\u0026#34;); const qs = require(\u0026#39;querystring\u0026#39;); const axios = require(\u0026#39;axios\u0026#39;); const jwt = require(\u0026#39;jsonwebtoken\u0026#39;); const serverOptions = { key: fs.readFileSync(\u0026#39;localhost-privkey.pem\u0026#39;), cert: fs.readFileSync(\u0026#39;localhost-cert.pem\u0026#39;) }; // fill your info var ClientID = \u0026#34;\u0026#34;; var ClientSercet = \u0026#34;\u0026#34;; var RedirectLink = \u0026#34;\u0026#34;; async function getTokenFromGoogle(get_token_url, value) { try { var res = await axios.post(get_token_url, qs.stringify(value), { headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39;, }, }); } catch(err) { console.log(err); } return res.data; } // read and send file content in the stream const sendFile = (stream, fileName) =\u0026gt; { const fd = fs.openSync(fileName, \u0026#34;r\u0026#34;); const stat = fs.fstatSync(fd); const headers = { \u0026#34;content-length\u0026#34;: stat.size, \u0026#34;last-modified\u0026#34;: stat.mtime.toUTCString(), \u0026#34;content-type\u0026#34;: mime.getType(fileName) }; stream.respondWithFD(fd, headers); // key point }; // handle requests const http2Handlers = (req, res) =\u0026gt; { // send empty response for favicon.ico if (req.url === \u0026#34;/favicon.ico\u0026#34;) { res.stream.respond({ \u0026#34;:status\u0026#34;: 200 }); res.stream.end(); return; } if (req.url === \u0026#34;/\u0026#34; || req.url === \u0026#34;/index.html\u0026#34; ) { req.url = \u0026#34;/index.html\u0026#34;; const fileName = __dirname + req.url; sendFile(res.stream, fileName); } // if else if (req.url.includes( \u0026#34;/api/oauth/google\u0026#34; ) ) { var parsed = url.parse(req.url); var query = qs.parse(parsed.query); var code = query.code; // get the toake with code var get_token_url = \u0026#34;https://oauth2.googleapis.com/token\u0026#34;; const value = { code, client_id: ClientID, client_secret: ClientSercet, redirect_uri: RedirectLink, grant_type: \u0026#34;authorization_code\u0026#34;, }; getTokenFromGoogle(get_token_url, value).then(function(result) { var googleUser = jwt.decode(result.id_token); res.write( \u0026#39;\u0026lt;h1\u0026gt; Hello \u0026#39; + googleUser.name + \u0026#39;\u0026lt;/h1\u0026gt;\u0026#39;); res.write(\u0026#39;Your email address: \u0026#39; + googleUser.email + \u0026#39;\u0026lt;br\u0026gt;\u0026#39;); res.write(\u0026#39;Locale: \u0026#39; + googleUser.locale + \u0026#39;\u0026lt;br\u0026gt;\u0026#39;); res.end(\u0026#39;\u0026lt;img src=\u0026#39; + googleUser.picture + \u0026#39; referrerpolicy=\u0026#34;no-referrer\u0026#34;/\u0026gt;\u0026#39;) console.log(googleUser); }); } }; http2 .createSecureServer(serverOptions, http2Handlers) .listen(HTTP2_PORT, () =\u0026gt; { console.log(\u0026#34;http2 server started on port\u0026#34;, HTTP2_PORT); }); ","permalink":"https://jonathan-tw.github.io/posts/middleware-architectures-2-hw/","summary":"AJAX / XHR states / CORS / Data access Tasks Create a simple HTML page with an info text field and a single button Implement a JavaScript function which is triggered when the button is clicked The function should fetch relatively large file (e.g. 100-200MB) in the text field show following states: loading - when the open method was called loaded - when the send method was called downloading - while the data is being downloaded finished downloading - when the data has beeen downloaded you can use Promise, async/await Description AJAX overview: Asynchronous JavaScript and XML technique for creating better, faster, and more interactive web applications relies on XML, JSON, HTML, CSS and JavaScript AJAX is not a programming language Running this demo by using the jquery module to achieve the ajax request. Following the xhr state in https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readyState.","title":"(課程筆記)(CTU in Prague) Middleware architectures 2 HW"},{"content":" OS:Ubuntu: 16.04 / 18.04\nOpencCV: 4.2\nCuda: 8.0 / 9.0\nNivida Driver: 418.56 (GTX 1050ti) / 435 (GTX 1060)\nCPU: i3-8300 3.70Ghz\nffmpeg: 4.2 / 4.2.4\nnv_codec_headers: 8.2 / 9.0\nInstall Nvidia Driver list available Nvidia Driver\n1 ubuntu-drivers devices add repoitory\n1 2 sudo add-apt-repository ppa:graphics-drivers/ppa sudo apt update instll Nvidia Driver\n1 sudo apt install nvidia-xxx Install CUDA Check CUDA and Nvidia driver compatibility https://docs.nvidia.com/deploy/cuda-compatibility/index.html\nDownload Cuda runfile which determines by your os https://developer.nvidia.com/cuda-downloads\nplease choose not to install nvidia graphics driver, or the driver will be updated**\ninstall cuda (ex: cuda 8.0 for ubuntnu 16.04 )\n1 sudo sh cuda_8.0.61_375.26_linux.run Add environment variables to ~/.bashrc\n1 2 3 4 sudo nano ~/.bashrc export PATH=/usr/local/cuda/bin:$PATH export LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH source ~/.bashrc Install NV_codec (optional for gpu ) download nv_codec_headers 8.2: https://github.com/FFmpeg/nv-codec-headers/tree/sdk/8.2\ninstall nv_codec_headers 8.2\n1 sudo make install nv_codec_headers 9.0需要cuda 9.0以上\nInstall FFmpeg 4.2.4 install necessary tool\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 sudo apt-get update -qq \u0026amp;\u0026amp; sudo apt-get -y install \\ autoconf \\ automake \\ build-essential \\ cmake \\ git-core \\ libass-dev \\ libfreetype6-dev \\ libgnutls28-dev \\ libsdl2-dev \\ libtool \\ libva-dev \\ libvdpau-dev \\ libvorbis-dev \\ libxcb1-dev \\ libxcb-shm0-dev \\ libxcb-xfixes0-dev \\ pkg-config \\ texinfo \\ wget \\ yasm \\ zlib1g-dev install libx264:\n1 2 3 4 git clone https://code.videolan.org/videolan/x264.git cd x264 sudo ./configure --enable-shared --disable-asm sudo make \u0026amp;\u0026amp; sudo make install installl ffplay\n1 sudo apt-get install libsdl2-dev install libfdk_aac (optional)\nhttps://sourceforge.net/projects/opencore-amr/files/fdk-aac/\n1 2 ./configure make \u0026amp;\u0026amp; sudo make install 1 2 3 vi /etc/ld/so.conf.d/aac.conf /usr/local/lib sudo ldconfig install mp3lame (optional)\n1 sudo apt-get install yasm libmp3lame-dev download ffmpeg:\n1 git clone https://git.ffmpeg.org/ffmpeg.git configure command (if you need cuvid)\n1 sudo ./configure --enable-libmp3lame --enable-libfdk_aac --enable-libx264 --enable-gpl --enable-cuda --enable-cuvid --enable-nvenc --enable-nonfree --enable-pic --enable-rpath --enable-shared --extra-cflags=-I/usr/local/cuda/include --extra-ldflags=-L/usr/local/cuda/lib64 --enable-libnpp --enable-ffplay configure command (if you don\u0026rsquo;t need cuvid and sound but want cuda )\n1 sudo ./configure --enable-libx264 --enable-gpl --enable-cuda --enable-nvenc --enable-nonfree --enable-rpath --enable-pic --enable-shared --extra-cflags=-I/usr/local/cuda/include --extra-ldflags=-L/usr/local/cuda/lib64 --enable-ffplay compile ffmpeg\n1 sudo make \u0026amp;\u0026amp; sudo make install add to envirnment\n1 2 3 4 5 6 7 sudo vi ~/.bashrc export PATH=/usr/local/bin:$PATH source ~/.bashrc sudo nano /etc/ld.so.conf # dertermine on your ffmpeg install location /usr/local/ffmpeg/lib sudo ldconfig for more build options https://trac.ffmpeg.org/wiki/CompilationGuide/Ubuntu\nTest ffmpeg Hardware acceleration methods:\n1 ffmpeg -hwaccels cpu:\n1 time ffmpeg -rtsp_transport tcp -i rtsp://admin:ai123456@192.168.0.111 -r 30 -t 100 -c:v h264 -b:v 2048k -vf scale=1280:-1 -y -c:v libx264 tcp_cpu_output.mp4 gpu:\n1 time ffmpeg -rtsp_transport tcp -hwaccel cuvid -c:v h264_cuvid -i rtsp://admin:ai123456@192.168.0.111 -r 30 -t 100 -b:v 2048k -vf scale_npp=1280:-1 -y -c:v h264_nvenc tcp_gpu_output.mp4 默認下ffmpeg抓rtsp使用UDP,這會lose大量packet，使用TCP避免。\nVideo.mp4 CPU GPU Real Time 16s 0.5s Bit rate 1497kbps 1479kbps rtsp://admin:ai123456@192.168.0.111 (30幀) CPU GPU Real Time 1m49s 1m41s Bit rate 1911kbps 2067kbps Install Opencv install required and optional package\n1 sudo add-apt-repository -y \u0026#34;deb http://security.ubuntu.com/ubuntu xenial-security main\u0026#34; 1 sudo apt-get install -y libjpeg8-dev libjasper-dev libpng12-dev 1 sudo apt install build-essential cmake git pkg-config libgtk-3-dev libavcodec-dev libavformat-dev libswscale-dev libv4l-dev libxvidcore-dev libx264-dev 1 sudo apt install libjpeg-dev libpng-dev libtiff-dev gfortran openexr libatlas-base-dev python3-dev python3-numpy libtbb2 libtbb-dev libdc1394-22-dev download opencv 4.2 and extra library\n1 2 3 4 5 6 7 mkdir opencv_base cd opencv_base git clone https://github.com/opencv/opencv.git --branch=4.2.0 git clone https://github.com/opencv/opencv_contrib.git --branch=4.2.0\tcd opencv_base/opencv/ mkdir build cd build with cuda and opencv_world check your cuda_arch_bin:https://developer.nvidia.com/cuda-gpus\n1 2 3 4 5 6 7 8 9 10 11 sudo cmake -D CMAKE_BUILD_TYPE=Release \\ -D OPENCV_GENERATE_PKGCONFIG=YES \\ -D CMAKE_INSTALL_PREFIX=/usr/local \\ -D BUILD_JAVA=YES \\ -D WITH_CUDA=ON \\ -D BUILD_opencv_world=ON \\ -D WITH_FFMPEG=ON \\ -D OPENCV_GENERATE_PKGCONFIG=ON \\ -D OPENCV_EXTRA_MODULES_PATH=/usr/local/opencv_base/opencv_contrib/modules \\ -D BUILD_opencv_python3=yes \\ -D CUDA_ARCH_BIN=6.1 .. without cuda (Simple) 1 2 3 4 5 6 7 8 9 10 11 sudo cmake -D CMAKE_BUILD_TYPE=RELEASE \\ -D OPENCV_GENERATE_PKGCONFIG=YES \\ -D CMAKE_INSTALL_PREFIX=/usr/local \\ -D BUILD_JAVA=YES \\ -D BUILD_opencv_world=ON \\ -D WITH_FFMPEG=ON \\ -D INSTALL_C_EXAMPLES=ON \\ -D INSTALL_PYTHON_EXAMPLES=ON \\ -D OPENCV_GENERATE_PKGCONFIG=ON \\ -D OPENCV_EXTRA_MODULES_PATH=/usr/local/opencv_base/opencv_contrib/modules \\ -D BUILD_EXAMPLES=ON .. Compile cuda \u0026amp;\u0026amp; ffmpeg with Opencv 開發指令 include及lib都為相對路徑 (if you want to pack code )\nTwo .so files need to be at system location libx264.so\n1 sudo cp lib/libx264.so.160 /lib/x86_64-linux-gnu/ libswresample.so\n1 sudo cp lib/libswresample.so.3 /usr/local/lib/ CUDA compiles to shared file (.so): (NV12toBGR) 1 nvcc -shared cuda_convert.cu -o ../lib/libcuda_convert.so --compiler-options \u0026#39;-fPIC\u0026#39; FFmpeg gpu server compiles to shared file (.so) 1 g++ -shared -fPIC ffmpeg_gpu_server.cpp -o ../lib/libffmpeg_gpu_server.so -I../include/ -L ../lib -Wl,--rpath=\u0026#39;../lib\u0026#39; -lavformat -lavcodec -lavutil -lswscale -lswresample -lcuda_convert -lx264 FFmpeg gpu client compiles 1 g++ ffmpeg_gpu_client.cpp -o ../bin/ffmpeg_gpu_client -I../include/ -Wl,--rpath=\u0026#39;../lib\u0026#39; -L -lffmpeg_gpu_server -lopencv_world -ldl -lm -lz -lX11 -std=gnu++11 ","permalink":"https://jonathan-tw.github.io/posts/ffmpeg_note_1/","summary":"OS:Ubuntu: 16.04 / 18.04 OpencCV: 4.2 Cuda: 8.0 / 9.0 Nivida Driver: 418.56 (GTX 1050ti) / 435 (GTX 1060) CPU: i3-8300 3.70Ghz ffmpeg: 4.2 / 4.2.4 nv_codec_headers: 8.2 / 9.0 Install Nvidia Driver list available Nvidia Driver 1 ubuntu-drivers devices add repoitory 1 2 sudo add-apt-repository ppa:graphics-drivers/ppa sudo apt update instll Nvidia Driver 1 sudo apt install nvidia-xxx Install CUDA Check CUDA and Nvidia driver compatibility https://docs.nvidia.com/deploy/cuda-compatibility/index.html Download Cuda runfile which determines by your os https://developer.nvidia.com/cuda-downloads please choose not to install nvidia graphics driver, or the driver will be updated** install cuda (ex: cuda 8.0 for ubuntnu 16.04 ) 1 sudo sh cuda_8.0.61_375.26_linux.run Add environment variables to ~/.bashrc 1 2 3 4 sudo nano ~/.bashrc export PATH=/usr/local/cuda/bin:$PATH export LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH source ~/.bashrc Install NV_codec (optional for gpu ) download nv_codec_headers 8.2: https://github.com/FFmpeg/nv-codec-headers/tree/sdk/8.2 install nv_codec_headers 8.2 1 sudo make install nv_codec_headers 9","title":"FFmpeg開發系列1 - FFmpeg、OpenCV、CUDA、NV_Codec GPU加速環境搭建"}]